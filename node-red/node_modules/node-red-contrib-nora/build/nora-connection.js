"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var nora_device_1 = require("./nora-device");
var NoraConnection = /** @class */ (function () {
    function NoraConnection(socket, logger) {
        var _this = this;
        this.socket = socket;
        this.destroy$ = new rxjs_1.Subject();
        this.deviceEvents$ = new rxjs_1.Subject();
        this.devices$ = this.deviceEvents$.pipe(operators_1.scan(function (devices, event) {
            switch (event.type) {
                case 'add':
                    return tslib_1.__spreadArrays(devices, [event.device]);
                case 'remove':
                    return devices.filter(function (d) { return d.id !== event.id; });
            }
        }, []), operators_1.publishReplay(1), operators_1.refCount());
        this.connected = new rxjs_1.BehaviorSubject(false);
        this.errors = new rxjs_1.Subject();
        this.connected$ = this.connected.asObservable();
        this.errors$ = this.errors.asObservable();
        socket.on('connect', function () { return _this.connected.next(true); });
        socket.on('disconnect', function () { return _this.connected.next(false); });
        this.connected.pipe(operators_1.switchMap(function (connected) { return connected === true
            ? _this.devices$.pipe(operators_1.debounceTime(1000))
            : rxjs_1.EMPTY; }), operators_1.takeUntil(this.destroy$)).subscribe(function (devices) {
            var syncDevices = {};
            for (var _i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
                var device = devices_1[_i];
                syncDevices[device.id] = device.config;
            }
            logger.info("nora: sync " + devices.length + " devices");
            socket.emit('sync', syncDevices, 'req:sync');
        });
        var update$ = new rxjs_1.Subject();
        update$.pipe(operators_1.withLatestFrom(this.devices$), operators_1.takeUntil(this.destroy$)).subscribe(function (_a) {
            var updates = _a[0], devices = _a[1];
            var updateIds = Object.keys(updates);
            var _loop_1 = function (id) {
                var device = devices.find(function (d) { return d.id === id; });
                if (!device) {
                    logger.warn("received update for missing device " + id);
                    return "continue";
                }
                var newState = updates[id];
                device.setState(newState);
            };
            for (var _i = 0, updateIds_1 = updateIds; _i < updateIds_1.length; _i++) {
                var id = updateIds_1[_i];
                _loop_1(id);
            }
        });
        var activate$ = new rxjs_1.Subject();
        activate$.pipe(operators_1.withLatestFrom(this.devices$), operators_1.takeUntil(this.destroy$)).subscribe(function (_a) {
            var activate = _a[0], devices = _a[1];
            var _loop_2 = function (id) {
                var device = devices.find(function (d) { return d.id === id; });
                if (!device) {
                    logger.warn("received activate state for missing device " + id);
                    return "continue";
                }
                device.activateScene(activate.deactivate);
            };
            for (var _i = 0, _b = activate.ids; _i < _b.length; _i++) {
                var id = _b[_i];
                _loop_2(id);
            }
        });
        socket.on('update', function (changes) { return update$.next(changes); });
        socket.on('action-error', function (reqId, msg) {
            if (reqId === 'req:sync') {
                logger.warn("nora: sync error (" + msg + ")");
            }
            else {
                _this.errors.next({ device: reqId.substring(4), msg: msg });
            }
        });
        socket.on('activate-scene', function (ids, deactivate) { return activate$.next({ ids: ids, deactivate: deactivate }); });
    }
    NoraConnection.prototype.addDevice = function (id, deviceConfig) {
        var _this = this;
        return new rxjs_1.Observable(function (observer) {
            var device = new nora_device_1.NoraDevice(id, deviceConfig, _this);
            _this.deviceEvents$.next({
                type: 'add',
                device: device,
            });
            observer.next(device);
            return function () {
                _this.deviceEvents$.next({
                    type: 'remove',
                    id: device.id,
                });
            };
        });
    };
    NoraConnection.prototype.destroy = function () {
        this.destroy$.next();
        this.destroy$.complete();
    };
    NoraConnection.prototype.sendDeviceUpdate = function (id, newState) {
        var _a;
        this.socket.emit('update', (_a = {}, _a[id] = newState, _a), "req:" + id);
    };
    return NoraConnection;
}());
exports.NoraConnection = NoraConnection;
