"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var socket_io_client_1 = tslib_1.__importDefault(require("socket.io-client"));
var nora_connection_1 = require("./nora-connection");
var NoraService = /** @class */ (function () {
    function NoraService(logger) {
        this.logger = logger;
        this.sockets = {};
    }
    NoraService.getService = function (RED) {
        if (!this.instance) {
            this.instance = new NoraService(RED.log);
        }
        return this.instance;
    };
    NoraService.prototype.getConnection = function (config, node, state) {
        var _this = this;
        if (state === void 0) { state = rxjs_1.EMPTY; }
        var key = (config.group || '') + ":" + config.token;
        var existing = this.sockets[key];
        if (!existing) {
            var stop = new rxjs_1.Subject();
            this.sockets[key] = existing = {
                connection$: this.createSocketObservable(config, stop),
                uses: 0,
                stop: stop,
            };
        }
        return new rxjs_1.Observable(function (observer) {
            existing.uses++;
            if (existing.stopTimer) {
                clearTimeout(existing.stopTimer);
            }
            var connected = new rxjs_1.Subject();
            var connected$ = connected.pipe(operators_1.switchMap(function (c) { return c; }), operators_1.startWith(false), operators_1.distinctUntilChanged());
            var updateStatus$ = rxjs_1.combineLatest([connected$, state])
                .pipe(operators_1.tap(function (_a) {
                var isConnected = _a[0], currentState = _a[1];
                node.status(isConnected
                    ? { fill: 'green', shape: 'dot', text: "connected " + currentState }
                    : { fill: 'red', shape: 'ring', text: 'not connected' });
            }), operators_1.ignoreElements());
            return rxjs_1.merge(updateStatus$, existing.connection$).pipe(operators_1.tap(function (nora) { return connected.next(nora.connected$); }), operators_1.finalize(function () {
                existing.uses--;
                connected.complete();
                if (existing.uses === 0) {
                    if (existing.stopTimer) {
                        clearTimeout(existing.stopTimer);
                    }
                    existing.stopTimer = setTimeout(function () {
                        if (existing.uses === 0) {
                            existing.stop.next();
                            existing.stop.complete();
                            delete _this.sockets[key];
                        }
                    }, 10000);
                }
            })).subscribe(observer);
        });
    };
    NoraService.prototype.createSocketObservable = function (_a, stop) {
        var _this = this;
        var token = _a.token, group = _a.group, notify = _a.notify;
        var id = token.substr(-5);
        return new rxjs_1.Observable(function (observer) {
            _this.logger.info("nora (" + id + "): connecting");
            var version = require('../package.json').version;
            var uri = "https://node-red-google-home.herokuapp.com/?version=" + version + "&token=" + encodeURIComponent(token) + "&notify=" + notify;
            if (group) {
                uri += "&group=" + encodeURIComponent(group);
            }
            var socket = socket_io_client_1.default(uri);
            var connection = new nora_connection_1.NoraConnection(socket, _this.logger);
            observer.next(connection);
            socket.on('connect', function () { return _this.logger.info("nora (" + id + "): connected"); });
            socket.on('disconnect', function (reason) { return _this.logger.warn("nora (" + id + "): disconnected (" + reason + ")"); });
            socket.on('error', function (err) {
                _this.logger.warn("nora (" + id + "): socket connection error: " + err);
                observer.error(new Error("nora: socket connection error: " + err));
            });
            return function () {
                _this.logger.info("nora (" + id + "): close connection");
                connection.destroy();
                socket.close();
            };
        }).pipe(operators_1.retryWhen(function (err) { return err.pipe(operators_1.delayWhen(function () {
            var seconds = Math.round(Math.random() * 120) / 2 + 5;
            _this.logger.warn("nora (" + id + "): reconnecting in " + seconds + " sec");
            return rxjs_1.timer(seconds * 1000);
        })); }), operators_1.takeUntil(stop), operators_1.publishReplay(1), operators_1.refCount());
    };
    return NoraService;
}());
exports.NoraService = NoraService;
