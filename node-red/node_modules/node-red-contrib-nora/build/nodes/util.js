"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ajv_1 = tslib_1.__importDefault(require("ajv"));
var path_1 = require("path");
function convertValueType(RED, value, type, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.defaultType, defaultType = _c === void 0 ? 'bool' : _c, _d = _b.defaultValue, defaultValue = _d === void 0 ? false : _d;
    if (type === 'flow' || type === 'global') {
        try {
            var parts = RED.util.normalisePropertyExpression(value);
            if (parts.length === 0) {
                throw new Error();
            }
        }
        catch (err) {
            value = defaultValue;
            type = defaultType;
        }
    }
    return { value: value, type: type };
}
exports.convertValueType = convertValueType;
function getValue(RED, node, value, type) {
    if (type === 'date') {
        return Date.now();
    }
    else {
        return RED.util.evaluateNodeProperty(value, type, node);
    }
}
exports.getValue = getValue;
function R(parts) {
    var substitutions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        substitutions[_i - 1] = arguments[_i];
    }
    var rounded = substitutions.map(function (sub) {
        if (typeof sub === 'number') {
            return Math.round(sub * 10) / 10;
        }
        return sub;
    });
    return String.raw.apply(String, tslib_1.__spreadArrays([parts], rounded));
}
exports.R = R;
function updateState(payload, state$, mapping) {
    if (typeof payload !== 'object') {
        return false;
    }
    var newState = tslib_1.__assign({}, state$.value);
    updateProperties(payload, newState, newState, mapping);
    state$.next(newState);
    return true;
}
exports.updateState = updateState;
function updateProperties(from, to, rootState, mapping, path) {
    if (path === void 0) { path = 'msg.payload.'; }
    var _a, _b;
    var _loop_1 = function (key, v) {
        var value = v;
        var mapTo = (_b = (_a = mapping === null || mapping === void 0 ? void 0 : mapping.find(function (m) { return m.from === key; })) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : key;
        var prevValue = to[mapTo];
        if (typeof prevValue !== typeof value) {
            if (typeof prevValue === 'number') {
                value = +value;
            }
            if (typeof prevValue === 'boolean') {
                value = !!value;
            }
        }
        if (typeof value === 'object' && typeof prevValue === 'object') {
            updateProperties(v, tslib_1.__assign({}, prevValue), rootState, mapping, "" + path + key + ".");
        }
        else {
            to[mapTo] = value;
            if (!validate('state', rootState)) {
                throw new Error("Invalid property " + path + key + " with value " + value);
            }
        }
    };
    for (var _i = 0, _c = Object.entries(from); _i < _c.length; _i++) {
        var _d = _c[_i], key = _d[0], v = _d[1];
        _loop_1(key, v);
    }
}
var ajv = new ajv_1.default();
var cachedValidators = {};
function validate(schemaName, object) {
    var validator = cachedValidators[schemaName];
    if (!validator) {
        var schema = require(path_1.join(__dirname, '..', 'schema', schemaName));
        cachedValidators[schemaName] = validator = ajv.compile(schema);
    }
    return validator(object);
}
